# 第四次作业

> 本次作业实现了一个双线程支持多任务的runtime，调用`runtime::block_on()`接口即可将异步函数放入runtime进行执行，对于主任务需要发出附属任务，可以使用`runtime::spawn()`方法将附属任务发出。其中主任务发出的附属任务会被双线程执行。在`task.rs`中设计了课件上的相关测试，并得到了预期结果，使用`cargo run`即可将课件中的作业都进行执行观察现象。

> 本次作业还设计了一个测试，其测试函数在`src/task.rs`中的`fn test_demo()`，能够调用多个附属任务，每个附属任务都会进行一个1000000次循环的计算。该测试主要为测试runtime的性能设计的（`cargo bench`不能在stable版本运行，所以在此使用`cargo test`进行代替），使用双线程调度后可以在终端使用`htop`工具发现该程序能占用200%左右的cpu，表明双线程正确实现。